<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of sc_compute</title>
  <meta name="keywords" content="sc_compute">
  <meta name="description" content="[BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">matlab</a> &gt; sc_compute.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for matlab&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>sc_compute
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>[BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> [BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);

 compute (r,theta) histograms for points along boundary 

 Bsamp is 2 x nsamp (x and y coords.)
 Tsamp is 1 x nsamp (tangent theta)
 out_vec is 1 x nsamp (0 for inlier, 1 for outlier)

 mean_dist is the mean distance, used for length normalization
 if it is not supplied, then it is computed from the data

 outliers are not counted in the histograms, but they do get
 assigned a histogram</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="dist2.html" class="code" title="function n2 = dist2(x, c)">dist2</a>	DIST2	Calculates squared distance between two sets of points.</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="do_match.html" class="code" title="function [sim, angle, sc_cost, E] = do_match(f1, f2)">do_match</a>	Author: Joshua Abraham</li><li><a href="register.html" class="code" title="function [fr, similarity] = register(f1,f2)">register</a>	Author: Joshua Abraham</li><li><a href="tps_iter_match.html" class="code" title="function [sc_cost, Et, cvec, angle] = tps_iter_match_1(m1, m2, X, Y, orients, nbins_theta, nbins_r, r_inner, r_outer, n_iter, r, beta_init, i1, i2, anchors)">tps_iter_match</a>	Author: Joshua Abraham</li><li><a href="tps_iter_match_no_anchors.html" class="code" title="function [sc_cost, Et, cvec, angle] = tps_iter_match_m1(m1, m2, X, Y, orients, nbins_theta, nbins_r, r_inner, r_outer, n_iter, r, beta_init, i1, i2, anchors)">tps_iter_match_no_anchors</a>	Author: Joshua Abraham</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);</a>
0002 <span class="comment">% [BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% compute (r,theta) histograms for points along boundary</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Bsamp is 2 x nsamp (x and y coords.)</span>
0007 <span class="comment">% Tsamp is 1 x nsamp (tangent theta)</span>
0008 <span class="comment">% out_vec is 1 x nsamp (0 for inlier, 1 for outlier)</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% mean_dist is the mean distance, used for length normalization</span>
0011 <span class="comment">% if it is not supplied, then it is computed from the data</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% outliers are not counted in the histograms, but they do get</span>
0014 <span class="comment">% assigned a histogram</span>
0015 <span class="comment">%</span>
0016 
0017 nsamp=size(Bsamp,2);
0018 in_vec=out_vec==0;
0019 
0020 <span class="comment">% compute r,theta arrays</span>
0021 r_array=real(sqrt(<a href="dist2.html" class="code" title="function n2 = dist2(x, c)">dist2</a>(Bsamp',Bsamp'))); <span class="comment">% real is needed to</span>
0022                                           <span class="comment">% prevent bug in Unix version</span>
0023 
0024 
0025 <span class="comment">%JI: This is an array with elements arctan(xi-xj, yi-yj)</span>
0026 
0027 theta_array_abs=atan2(Bsamp(2,:)'*ones(1,nsamp)-ones(nsamp,1)*Bsamp(2,:),Bsamp(1,:)'*ones(1,nsamp)-ones(nsamp,1)*Bsamp(1,:))';
0028 
0029 theta_array=theta_array_abs-Tsamp'*ones(1,nsamp);
0030 
0031 <span class="comment">% create joint (r,theta) histogram by binning r_array and</span>
0032 <span class="comment">% theta_array</span>
0033 
0034 <span class="comment">% normalize distance by mean, ignoring outliers</span>
0035 <span class="keyword">if</span> isempty(mean_dist)
0036    tmp=r_array(in_vec,:);   <span class="comment">%JI: removes rows not in in_vec</span>
0037    tmp=tmp(:,in_vec);       <span class="comment">%JI: removes cols not in in_vec</span>
0038    mean_dist=mean(tmp(:));  <span class="comment">%JI: global mean</span>
0039 <span class="keyword">end</span>
0040 r_array_n=r_array/mean_dist;
0041 
0042 <span class="comment">% use a log. scale for binning the distances</span>
0043 r_bin_edges=logspace(log10(r_inner),log10(r_outer), nbins_r);
0044 r_array_q=zeros(nsamp,nsamp);
0045 <span class="keyword">for</span> m=1:nbins_r
0046    r_array_q=r_array_q+(r_array_n&lt;r_bin_edges(m));
0047 <span class="keyword">end</span>
0048 fz=r_array_q&gt;0; <span class="comment">% flag all points inside outer boundary</span>
0049 
0050 <span class="comment">% put all angles in [0,2pi) range</span>
0051 theta_array_2 = rem(rem(theta_array,2*pi)+2*pi,2*pi);
0052 <span class="comment">% quantize to a fixed set of angles (bin edges lie on 0,(2*pi)/k,...2*pi</span>
0053 theta_array_q = 1+floor(theta_array_2/(2*pi/nbins_theta));
0054 
0055 
0056 <span class="comment">%JI:</span>
0057 <span class="comment">%Gaussian array</span>
0058 
0059 gauss_dist =  repmat(exp( -((r_bin_edges - r_outer ).^2/2.5))', 1, nbins_theta);
0060 gauss_dist = sort(gauss_dist(:)');
0061 
0062 nbins=nbins_theta*nbins_r;
0063 BH=zeros(nsamp,nbins);
0064 <span class="keyword">for</span> n=1:nsamp
0065    fzn=fz(n,:)&amp;in_vec;
0066    Sn=sparse(theta_array_q(n,fzn),r_array_q(n,fzn),1,nbins_theta,nbins_r) ;
0067    BH(n,:)= Sn(:)' .*  gauss_dist;
0068    
0069 <span class="keyword">end</span>
0070 
0071 
0072 
0073</pre></div>
<hr><address>Generated on Wed 16-Apr-2014 19:12:41 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>