<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of do_match</title>
  <meta name="keywords" content="do_match">
  <meta name="description" content="Author: Joshua Abraham">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">matlab</a> &gt; do_match.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for matlab&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>do_match
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Author: Joshua Abraham</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [sim, angle, sc_cost, E] = do_match(f1, f2) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">    Author: Joshua Abraham
    Email: algorithm007@hotmail.com
    Description: match a test fingerprint of image 'f1' to a template fingerprint of image 'f2'.
                 Preprocessing and feature extraction must already be performed (see extract_db.m).</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="calc_orient.html" class="code" title="function [similarity, index, r_g] = calc_orient(A, rA, B, rB, W)">calc_orient</a>	JI</li><li><a href="dist2.html" class="code" title="function n2 = dist2(x, c)">dist2</a>	DIST2	Calculates squared distance between two sets of points.</li><li><a href="hist_cost_2.html" class="code" title="function [HC]=hist_cost_2(BH1,BH2, r_inner, r_outer, nbins_theta, nbins_r);">hist_cost_2</a>	HC=hist_cost_2(BH1,BH2);</li><li><a href="register.html" class="code" title="function [fr, similarity] = register(f1,f2)">register</a>	Author: Joshua Abraham</li><li><a href="sc_compute.html" class="code" title="function [BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);">sc_compute</a>	[BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);</li><li><a href="tps_iter_match.html" class="code" title="function [sc_cost, Et, cvec, angle] = tps_iter_match_1(m1, m2, X, Y, orients, nbins_theta, nbins_r, r_inner, r_outer, n_iter, r, beta_init, i1, i2, anchors)">tps_iter_match</a>	Author: Joshua Abraham</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="main.html" class="code" title="">main</a>	Author: Joshua Abraham</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%    Author: Joshua Abraham</span>
0002 <span class="comment">%    Email: algorithm007@hotmail.com</span>
0003 <span class="comment">%    Description: match a test fingerprint of image 'f1' to a template fingerprint of image 'f2'.</span>
0004 <span class="comment">%                 Preprocessing and feature extraction must already be performed (see extract_db.m).</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%</span>
0007 
0008 <a name="_sub0" href="#_subfunctions" class="code">function [sim, angle, sc_cost, E] = do_match(f1, f2)</a>
0009 
0010 <span class="comment">%load template fingerprint</span>
0011 X=csvread( [char(f1) <span class="string">'.X'</span>]);
0012 m1=csvread( [char(f1) <span class="string">'.m'</span>]);
0013 oX=load( [char(f1) <span class="string">'.o'</span>]);
0014 rX=load( [char(f1) <span class="string">'.r'</span>]);
0015 nX = load( [char(f1) <span class="string">'.n'</span>]);  
0016 roX = load( [char(f1) <span class="string">'.ro'</span>]);
0017 orient_img_x = [];<span class="comment">%load( [char(f1) '.oi']);</span>
0018 or_x = [];<span class="comment">%load( [char(f1) '.oi']);</span>
0019 
0020 <span class="comment">%load test fingerprint</span>
0021 Y=csvread( [char(f2) <span class="string">'.X'</span>]);
0022 m2=csvread( [char(f2) <span class="string">'.m'</span>]);
0023 oY=load( [char(f2) <span class="string">'.o'</span>]);
0024 rY=load( [char(f2) <span class="string">'.r'</span>]);
0025 nY = load( [char(f2) <span class="string">'.n'</span>]);  
0026 roY = load( [char(f2) <span class="string">'.ro'</span>]);
0027 orient_img_y = [];<span class="comment">%load( [char(f2) '.oi']);</span>
0028 or_y = [];<span class="comment">%load( [char(f2) '.oi']);</span>
0029 
0030 
0031 <span class="comment">%Make sure all minutiae type are ridge endings, bifurcations, or primary cores (pseudo minutia).</span>
0032 i1=find(m1(:,3)&lt;7);
0033 i2=find(m2(:,3)&lt;7);
0034 X=X(i1,:);
0035 m1=m1(i1,:);
0036 Y=Y(i2,:);
0037 m2=m2(i2,:);
0038 m1r=m1(:,4);
0039 m2r=m2(:,4);
0040 m1(:,4)=mod(m1(:,4),pi);
0041 m2(:,4)=mod(m2(:,4),pi);
0042 
0043 <span class="comment">%Attempt to retrieve index of both test and template fingerprint core indexes (provided they exist).</span>
0044 test = m1(:,3);
0045 ic1  = find(test == 5);
0046 c1o = -1;
0047 c2o = -1;
0048 test = m2(:,3);
0049 ic2  = find(test == 5);
0050 
0051 
0052 <span class="comment">%Build fingerprint feature structure.</span>
0053 f1=struct(<span class="string">'X'</span>, X, <span class="string">'M'</span>, m1, <span class="string">'O'</span>, oX, <span class="string">'R'</span>, rX, <span class="string">'N'</span>, nX, <span class="string">'RO'</span>,roX, <span class="string">'OIMG'</span>, orient_img_x, <span class="string">'OREL'</span>, or_x); 
0054 f2=struct(<span class="string">'X'</span>, Y, <span class="string">'M'</span>, m2, <span class="string">'O'</span>, oY, <span class="string">'R'</span>, rY, <span class="string">'N'</span>, nY, <span class="string">'RO'</span>,roY, <span class="string">'OIMG'</span>, orient_img_y, <span class="string">'OREL'</span>, or_y); 
0055 
0056 <span class="comment">%Bending energy</span>
0057 E=0;
0058 
0059 <span class="comment">%Detect if the core is near the edge of the fingerprint. Edge core comparisons have their similarity</span>
0060 <span class="comment">%reduced since they are more prone to error due to lack of distributed coverage about the core point</span>
0061 <span class="comment">%(i.e. much more possible alignment combinations are achieved when minutiae only lie on one side</span>
0062 <span class="comment">% of a core point since we have less rotational contraints).</span>
0063 edge_core = 0;
0064 <span class="keyword">if</span> numel(ic1) &gt; 0 &amp;&amp; numel(ic2) &gt; 0
0065    a=max(f1.X(:,1));
0066    b=min(f1.X(:,1));
0067    <span class="keyword">if</span> f1.X(ic1,1) &gt; a-0.02 || f1.X(ic1,1) &lt; b+0.02
0068       edge_core=1
0069    <span class="keyword">end</span>
0070    a=max(f2.X(:,1));
0071    b=min(f2.X(:,1));
0072    <span class="keyword">if</span> f2.X(ic2,1) &gt; a-0.02 || f2.X(ic2,1) &lt; b+0.02
0073       edge_core=1
0074    <span class="keyword">end</span>
0075 <span class="keyword">end</span>
0076 
0077 <span class="comment">%Swap structures to make sure X represents the fingerprint with fewer minutiae</span>
0078 <span class="keyword">if</span> size(X,1) &gt; size(Y,1)
0079   temp = f1;
0080   f1 = f2;
0081   f2 = temp;
0082   temp = ic1;
0083   ic1 = ic2;
0084   ic2 = temp;
0085   temp = m1r;
0086   m1r = m2r;
0087   m2r = temp;
0088 <span class="keyword">end</span>
0089 
0090 display_flag=0;
0091 GC=0;
0092 
0093 mean_dist_global=[]; <span class="comment">% use [] to estimate scale from the data</span>
0094 
0095 nbins_theta=19; 
0096 nbins_r=5;
0097 eps_dum=1;  
0098 r=0.35; <span class="comment">% annealing rate</span>
0099 beta_init=0.8;  <span class="comment">% initial regularization parameter (normalized)</span>
0100 
0101 r_inner=1/8; 
0102 r_outer=1/2;  
0103 
0104 <span class="comment">%Register fingerprints</span>
0105 [ft,res]=<a href="register.html" class="code" title="function [fr, similarity] = register(f1,f2)">register</a>(f1,f2);
0106 angle=0;
0107 nsamp1=size(f1.X,1);
0108 nsamp2=size(f2.X,1);
0109 out_vec_1=zeros(1,nsamp1); 
0110 out_vec_2=zeros(1,nsamp2);
0111 
0112 d1=<a href="dist2.html" class="code" title="function n2 = dist2(x, c)">dist2</a>(f1.X, f1.X);
0113 d2=<a href="dist2.html" class="code" title="function n2 = dist2(x, c)">dist2</a>(f2.X, f2.X);
0114 
0115 o_res=[];
0116 sc_res=[];
0117 mc_res=[];
0118 ro_res=[];
0119 
0120 <span class="comment">%Map out binding box for overlap region.</span>
0121 xt = min(ft.X(:,2));
0122 xb = max(ft.X(:,2));
0123 xl = min(ft.X(:,1));
0124 xr = max(ft.X(:,1));
0125 yt = min(f2.X(:,2));
0126 yb = max(f2.X(:,2));
0127 yl = min(f2.X(:,1));
0128 yr = max(f2.X(:,1));
0129 region_t=max(xt, yt);
0130 region_b=min(xb, yb);
0131 region_r=min(xr, yr);
0132 region_l=max(xl, yl);
0133 region_a = (region_b - region_t)*(region_r-region_l);
0134 
0135 <span class="comment">%Find all indices within bounding box</span>
0136 ind1=intersect(intersect(find(ft.X(:,1) &gt; region_l), find(ft.X(:,1) &lt; region_r)), intersect(find(ft.X(:,2) &gt; region_t), find(ft.X(:,2) &lt; region_b))  );
0137 ind2=intersect(intersect(find(f2.X(:,1) &gt; region_l), find(f2.X(:,1) &lt; region_r)), intersect(find(f2.X(:,2) &gt; region_t), find(f2.X(:,2) &lt; region_b))  );
0138 
0139 <span class="comment">%get minutiae count for each image in overlap region</span>
0140 ng_samp1=numel(ind1);
0141 ng_samp2=numel(ind2);
0142 
0143 <span class="keyword">if</span> numel(res.map) &gt; 0 
0144    <span class="keyword">if</span> numel(ic1) &gt; 0 &amp;&amp; numel(ic2) &gt; 0
0145       GC=1;
0146    <span class="keyword">end</span>
0147 
0148    f1=ft;
0149    inda1=res.map1;
0150    inda2=res.map2; 
0151 
0152    <span class="comment">%find tighter minutiae count if possible for non core images</span>
0153    <span class="comment">%which are more likely to have a much smaller overlap area</span>
0154    <span class="comment">%then suggested by the bounding box. Convex hull structures</span>
0155    <span class="comment">%may be more accurate here.</span>
0156 
0157    <span class="keyword">if</span> GC ~=1 &amp;&amp; ng_samp1*ng_samp2 &gt; numel(inda1)*numel(inda2)
0158       <span class="comment">% overlap region minutiae counts are set to nearest neighbour minutiae index counts</span>
0159       ng_samp1=numel(inda1);
0160       ng_samp2=numel(inda2);
0161    <span class="keyword">end</span>
0162 
0163    <span class="comment">% overlap region index sets have anchor minutiae indexes removed.</span>
0164    inda1=setdiff(inda1(find(f1.M(inda1,3) &lt; 5)),res.map(:,1));
0165    inda2=setdiff(inda2(find(f2.M(inda2,3) &lt; 5)),res.map(:,2));
0166 
0167    y=0;
0168    redo=[];
0169 <span class="comment">%   for i=1:size(res.map,1)</span>
0170 <span class="comment">%       a1=mod(m1r(res.map(i,1))-res.angle,2*pi);</span>
0171 <span class="comment">%       a2=m2r(res.map(i,2));</span>
0172 
0173 <span class="comment">%       if min(abs(a1-a2), 2*pi-abs(a1-a2)) &gt; pi/8 &amp;&amp; f1.M(res.map(i,1),3) == f2.M(res.map(i,2),3)</span>
0174 <span class="comment">%          y=y+1;</span>
0175 <span class="comment">%          redo(y)=i;</span>
0176 <span class="comment">%          inda1(numel(inda1)+1)=res.map(i,1);</span>
0177 <span class="comment">%          inda2(numel(inda2)+1)=res.map(i,2);</span>
0178 <span class="comment">%       end</span>
0179 <span class="comment">%   end</span>
0180 
0181    res.map=res.map(setdiff(1:size(res.map,1), redo),:);
0182    f1.M(:,4)=mod(m1r-res.angle,2*pi);
0183 
0184    orients=[];
0185    <span class="keyword">for</span> i=1:numel(inda1)
0186        <span class="keyword">for</span> j=1:numel(inda2)
0187            <span class="keyword">if</span> f1.M(inda1(i),3) &lt; 5 &amp;&amp; f2.M(inda2(j),3) &lt; 5 
0188               orients(i,j) = <a href="calc_orient.html" class="code" title="function [similarity, index, r_g] = calc_orient(A, rA, B, rB, W)">calc_orient</a>(f1.X(inda1(i),:), f1.R(inda1(i),:), f2.X(inda2(j),:), f2.R(inda2(j),:), []);
0189            <span class="keyword">else</span>
0190               orients(i,j)=0;
0191            <span class="keyword">end</span>
0192        <span class="keyword">end</span>
0193    <span class="keyword">end</span>
0194 
0195    <span class="keyword">if</span> numel(inda1) &gt; 1 &amp;&amp; numel(inda2 ) &gt; 1
0196      <span class="keyword">if</span> numel(inda1) &gt; numel(inda2)
0197         orients=orients';
0198         t_res_map=res.map(:,[2,1]);
0199         [sc_cost3, E, cvec,angle] = <a href="tps_iter_match.html" class="code" title="function [sc_cost, Et, cvec, angle] = tps_iter_match_1(m1, m2, X, Y, orients, nbins_theta, nbins_r, r_inner, r_outer, n_iter, r, beta_init, i1, i2, anchors)">tps_iter_match</a>(f2.M, f1.M, f2.X, f1.X, orients, nbins_theta, nbins_r,r_inner,r_outer,3, r, beta_init, inda2, inda1, t_res_map);
0200         <span class="keyword">if</span> numel(cvec) &gt; 0
0201            xx=[inda1(cvec(:,2)); inda2(cvec(:,1))]'
0202            res.map=[res.map; xx]; 
0203         <span class="keyword">end</span>
0204      <span class="keyword">else</span>
0205         [sc_cost3, E, cvec,angle] = <a href="tps_iter_match.html" class="code" title="function [sc_cost, Et, cvec, angle] = tps_iter_match_1(m1, m2, X, Y, orients, nbins_theta, nbins_r, r_inner, r_outer, n_iter, r, beta_init, i1, i2, anchors)">tps_iter_match</a>(f1.M, f2.M, f1.X, f2.X, orients, nbins_theta, nbins_r,r_inner,r_outer,3, r, beta_init, inda1, inda2, res.map);
0206 
0207         <span class="keyword">if</span> numel(cvec) &gt; 0
0208            xx=[inda1(cvec(:,1)); inda2(cvec(:,2))]'
0209            res.map=[res.map; xx]; 
0210         <span class="keyword">end</span>
0211      <span class="keyword">end</span>
0212    <span class="keyword">end</span>
0213 
0214    d1=sqrt(<a href="dist2.html" class="code" title="function n2 = dist2(x, c)">dist2</a>(f1.X,f1.X));
0215    d2=sqrt(<a href="dist2.html" class="code" title="function n2 = dist2(x, c)">dist2</a>(f2.X,f2.X));
0216 
0217    s1=numel(find(f1.M(:,3) &lt; 5));
0218    s2=numel(find(f2.M(:,3) &lt; 5));
0219 <span class="keyword">else</span>
0220    res.map=[];
0221    res.o_res=[];
0222 <span class="keyword">end</span>
0223 
0224 
0225 nX=[];
0226 nY=[];
0227 
0228 ns=3;
0229 n_weight=[];
0230 same_type=[];
0231 
0232 
0233 <span class="keyword">if</span> numel(res.map) &gt; 0 
0234    <span class="keyword">for</span> i=1:size(res.map,1)
0235        <span class="keyword">if</span> res.map(i,1) == 0 
0236           <span class="keyword">continue</span>
0237        <span class="keyword">end</span>    
0238        x=m1(res.map(i,1),1); 
0239        y=m1(res.map(i,1),2); 
0240 
0241        bonus=1;
0242        a1=mod(m1r(res.map(i,1))-res.angle,2*pi);
0243        a2=m2r(res.map(i,2));
0244 
0245        bonus=bonus*exp(-min(abs(a1-a2), 2*pi-abs(a1-a2)));
0246 
0247        <span class="keyword">if</span> GC==1 &amp;&amp; f1.M(res.map(i,1),3) ~= f2.M(res.map(i,2),3) 
0248           bonus=bonus-0.1;
0249           same_type(i)=0;
0250        <span class="keyword">else</span>
0251           same_type(i)=1;
0252        <span class="keyword">end</span>
0253 
0254        [dx,ii]=sort(d1(res.map(i,1),:));
0255        [dy,jj]=sort(d2(res.map(i,2),:));
0256        dd1=f1.N((res.map(i,1)-1)*(s1-1) + 1:(res.map(i,1)-1)*(s1-1) + ns,3:9);
0257        dd2=f2.N((res.map(i,2)-1)*(s2-1) + 1:(res.map(i,2)-1)*(s2-1) + ns,3:9);
0258        dd1(:,3)=mod(dd1(:,3)-res.angle,2*pi);
0259        dd2(:,3)=mod(dd2(:,3),2*pi);
0260        dd1(:,7)=mod(dd1(:,3),pi);
0261        dd2(:,7)=mod(dd2(:,3),pi);
0262 
0263        used=[];
0264        m_score = 0;
0265        t=1;
0266        <span class="keyword">for</span> x=1:ns
0267            <span class="keyword">for</span> y=1:ns
0268                   <span class="keyword">if</span> numel(find(used==y)) 
0269                      <span class="keyword">continue</span>
0270                   <span class="keyword">end</span>
0271                   a_diff = min(abs(dd1(x,3)-dd2(y,3)), 2*pi-abs(dd1(x,3)-dd2(y,3)) );
0272                   dist_diff =  abs(dd1(x,1) - dd2(y,1));
0273                   lo_diff =  abs(dd1(x,6) - dd2(y,6));
0274                   o_diff=min(abs(dd1(x,7)-dd2(y,7)), pi-abs(dd1(x,7)-dd2(y,7)));
0275                   <span class="keyword">if</span> dist_diff &lt; 0.05 &amp;&amp; a_diff &lt; pi/2
0276                      m_score=m_score + exp(-o_diff)*exp(-dist_diff)*exp(-a_diff);
0277                      used(t)=y; t=t+1;
0278                   <span class="keyword">end</span>
0279            <span class="keyword">end</span>
0280         <span class="keyword">end</span>
0281         <span class="keyword">if</span> m_score == 0 
0282 <span class="comment">%          continue</span>
0283         <span class="keyword">end</span>
0284 
0285         n_weight(i)=m_score + bonus; 
0286 
0287        rox=f1.RO(res.map(i,1),:);
0288        roy=f2.RO(res.map(i,2),:);
0289        mox=f1.M(res.map(i,1),4);
0290        moy=f2.M(res.map(i,2),4);
0291        z=min([abs(mox-moy), abs(pi - abs(mox-moy))]) * 2/pi;
0292 
0293        t1=find(rox &lt; 0);
0294        t2=find(roy &lt; 0);
0295        t=[t1 t2 9];
0296        <span class="keyword">if</span> numel(min(t)) &gt; 0 
0297           rox=rox(1:min(t)-1);
0298           roy=roy(1:min(t)-1);
0299           ro_res(i)=max(abs(rox-roy));
0300           <span class="keyword">if</span> ro_res(i) &lt; 0.1 &amp;&amp; min(t)&gt;4
0301              n_weight(i)=n_weight(i)+0.2;
0302           <span class="keyword">end</span>
0303        <span class="keyword">else</span>
0304           ro_res(i)=0;
0305        <span class="keyword">end</span>
0306 
0307        [o_res(i), ih]= <a href="calc_orient.html" class="code" title="function [similarity, index, r_g] = calc_orient(A, rA, B, rB, W)">calc_orient</a>(f1.O(res.map(i,1),:), f1.R(res.map(i,1),:), f2.O(res.map(i,2),:), f2.R(res.map(i,2),:), [1:1]');  
0308 
0309        mc_res(i)=z;
0310        sc_res(i)=1;<span class="comment">%costmat(res.map(i,1),res.map(i,2));</span>
0311        res.map(setdiff(i,find(res.map(:,1)==res.map(i,1))), 1)=0;     
0312        res.map(setdiff(i,find(res.map(:,2)==res.map(i,2))), 1)=0;     
0313    <span class="keyword">end</span>
0314 <span class="keyword">end</span>
0315 
0316 sc_cost=100;
0317 
0318 <span class="keyword">if</span> numel(o_res) &gt; 1
0319    inda1=union(inda1,res.map(:,1));
0320    inda2=union(inda2,res.map(:,2));
0321 
0322    A=f1.X(inda1,:);
0323    B=f2.X(inda2,:);
0324    out_vec_1=zeros(1,size(A,1)); 
0325    out_vec_2=zeros(1,size(B,1));
0326 
0327    [BH1,mean_dist_1]=<a href="sc_compute.html" class="code" title="function [BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);">sc_compute</a>(A',f1.M(inda1,4)',mean_dist_global,nbins_theta,nbins_r,r_inner,r_outer,out_vec_1);
0328    [BH2,mean_dist_2]=<a href="sc_compute.html" class="code" title="function [BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);">sc_compute</a>(B',f2.M(inda2,4)',mean_dist_1,nbins_theta,nbins_r,r_inner,r_outer,out_vec_2);
0329    <span class="comment">%compute pairwise cost between all shape contexts</span>
0330    costmat=<a href="hist_cost_2.html" class="code" title="function [HC]=hist_cost_2(BH1,BH2, r_inner, r_outer, nbins_theta, nbins_r);">hist_cost_2</a>(BH1,BH2,r_inner, r_outer, nbins_theta, nbins_r);
0331    sc_vals=[];
0332 
0333    <span class="keyword">for</span> i=1:numel(res.map)/2
0334        <span class="keyword">if</span> numel(costmat(find(inda1==res.map(i,1)), find(inda2==res.map(i,2)))) &gt; 0
0335           sc_vals(i)=costmat(find(inda1==res.map(i,1)), find(inda2==res.map(i,2)));
0336        <span class="keyword">else</span>
0337           sc_vals(i)=10;
0338        <span class="keyword">end</span>
0339    <span class="keyword">end</span>
0340    sc_cost=mean(sc_vals);<span class="comment">%/exp(-(0.7-max(sqrt(res.area),0)))</span>
0341 
0342 
0343 <span class="keyword">end</span>
0344 
0345 unknown_c=numel(find(o_res == -1));
0346 
0347 ind=intersect(find(o_res &gt; 0.25), find(ro_res &lt; 0.897)); 
0348 
0349 <span class="keyword">for</span> i=1:numel(ind)
0350     dd1=f1.N((res.map(ind(i),1)-1)*(s1-1) + 1:(res.map(ind(i),1)-1)*(s1-1) + ns,3:9);
0351     dd2=f2.N((res.map(ind(i),2)-1)*(s2-1) + 1:(res.map(ind(i),2)-1)*(s2-1) + ns,3:9);
0352 <span class="keyword">end</span>
0353 
0354 o_res=o_res(ind);
0355 ro_res=ro_res(ind);
0356 mc_res=mc_res(ind);
0357 sc_res=sc_res(ind);
0358 n_weight=n_weight(ind);
0359 same_type=same_type(ind);
0360 <span class="comment">%o_res=o_res.*n_weight;</span>
0361 
0362 res.sc/res.area;
0363 res.sc;
0364 ro_res; <span class="comment">%=1/(sum(ro_res)/numel(ro_res))</span>
0365 o_res ;<span class="comment">%=sum(o_res)/numel(o_res)</span>
0366 n_weight;
0367 mc_res; <span class="comment">%=1/sum(mc_res)/numel(mc_res)</span>
0368 sc_res;
0369 
0370 nX=intersect(nX,ind1);
0371 nY=intersect(nY,ind2);
0372 numel(ind);
0373 size(res.map,1);
0374 
0375 ns1=numel(nX);
0376 ns2=numel(nY);
0377 
0378 ng_samp1=ng_samp1-unknown_c        <span class="comment">%=ns1; %ng_samp1+(ns1/2);</span>
0379 ng_samp2=ng_samp2-unknown_c        <span class="comment">%=ns2; %ng_samp2+(ns2/2);</span>
0380 
0381 ic1  = find(f1.M(:,3) == 5);
0382 ic2  = find(f2.M(:,3) == 5);
0383 
0384 <span class="comment">%a=abs(ns1-ng_samp1) + abs(ns2-ng_samp2)</span>
0385 <span class="comment">%4</span>
0386 
0387 o_a=zeros(numel(ind), numel(ind));
0388 o_b=zeros(numel(ind), numel(ind));
0389 <span class="keyword">for</span> i=1:numel(ind)
0390     <span class="keyword">for</span> j=i+1:numel(ind) 
0391         [o_a(i,j),ia,ra]=<a href="calc_orient.html" class="code" title="function [similarity, index, r_g] = calc_orient(A, rA, B, rB, W)">calc_orient</a>(f1.O(res.map(i,1),:), f1.R(res.map(i,1),:), f1.O(res.map(j,1),:), f1.R(res.map(j,1),:),[]);  
0392         [o_b(i,j),ib,rb]=<a href="calc_orient.html" class="code" title="function [similarity, index, r_g] = calc_orient(A, rA, B, rB, W)">calc_orient</a>(f2.O(res.map(i,2),:), f2.R(res.map(i,2),:), f2.O(res.map(j,2),:), f2.R(res.map(j,2),:), []);  
0393         o_a=min(o_a, 1);
0394         o_b=min(o_b, 1);
0395 
0396         <span class="keyword">if</span> (numel(intersect(ra,rb)) &lt; 120)
0397            o_a(i,j)=0;
0398            o_b(i,j)=0;
0399         <span class="keyword">end</span>          
0400  
0401         o_a(j,i)=o_a(i,j);
0402         o_b(j,i)=o_b(i,j);
0403     <span class="keyword">end</span>
0404 <span class="keyword">end</span>
0405 
0406 
0407 vv=1;
0408 <span class="keyword">if</span> (numel(mc_res) &gt;= 2) &amp;&amp; res.area &gt; -1
0409          hold on
0410 <span class="comment">%         figure(1)</span>
0411          subplot(2,2,4);
0412          plot(f1.X(:,1),f1.X(:,2),<span class="string">'b+'</span>,f2.X(:,1),f2.X(:,2),<span class="string">'ro'</span>)
0413          <span class="keyword">if</span> GC == 1
0414   <span class="comment">%          plot(f1.X(ic1,1),f1.X(ic1,2),'g+',f2.X(ic2,1),f2.X(ic2,2),'go')</span>
0415          <span class="keyword">end</span> 
0416          title([<span class="string">'final'</span>])
0417          hold off
0418          drawnow
0419 
0420    v=max(abs(o_a-o_b));
0421    vv=median(v)
0422    sim=(numel(mc_res)^2)*sqrt(max(o_res))*mean(n_weight)/max((ng_samp1*ng_samp2),1);
0423    <span class="keyword">if</span> edge_core == 1
0424       sim=sim*0.5;
0425    <span class="keyword">end</span>
0426 <span class="keyword">else</span>
0427    sim=0;
0428 <span class="keyword">end</span>
0429 sc_cost
0430 sim
0431</pre></div>
<hr><address>Generated on Wed 16-Apr-2014 19:12:41 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>