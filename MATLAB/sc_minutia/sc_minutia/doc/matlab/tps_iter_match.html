<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of tps_iter_match</title>
  <meta name="keywords" content="tps_iter_match">
  <meta name="description" content="Author: Joshua Abraham">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">matlab</a> &gt; tps_iter_match.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for matlab&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>tps_iter_match
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Author: Joshua Abraham</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [sc_cost, Et, cvec, angle] = tps_iter_match_1(m1, m2, X, Y, orients, nbins_theta, nbins_r, r_inner, r_outer, n_iter, r, beta_init, i1, i2, anchors) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">    Author: Joshua Abraham
    Email: algorithm007@hotmail.com
    Description: Performs a heavily modified iterative TPS warping based the freely available
    Shape Context code by (paper found at http://www.eecs.berkeley.edu/Research/Projects/CS/vision/shape/pami.html)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="bookstein.html" class="code" title="function [cx,cy,E,L]=bookstein(X,Y,beta_k);">bookstein</a>	[cx,cy,E,L]=bookstein(X,Y,beta_k);</li><li><a href="dist2.html" class="code" title="function n2 = dist2(x, c)">dist2</a>	DIST2	Calculates squared distance between two sets of points.</li><li><a href="hist_cost_2.html" class="code" title="function [HC]=hist_cost_2(BH1,BH2, r_inner, r_outer, nbins_theta, nbins_r);">hist_cost_2</a>	HC=hist_cost_2(BH1,BH2);</li><li><a href="hungarian.html" class="code" title="function [C,T]=hungarian(A)">hungarian</a>	HUNGARIAN Solve the Assignment problem using the Hungarian method.</li><li><a href="sc_compute.html" class="code" title="function [BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);">sc_compute</a>	[BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="do_match.html" class="code" title="function [sim, angle, sc_cost, E] = do_match(f1, f2)">do_match</a>	Author: Joshua Abraham</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%    Author: Joshua Abraham</span>
0002 <span class="comment">%    Email: algorithm007@hotmail.com</span>
0003 <span class="comment">%    Description: Performs a heavily modified iterative TPS warping based the freely available</span>
0004 <span class="comment">%    Shape Context code by (paper found at http://www.eecs.berkeley.edu/Research/Projects/CS/vision/shape/pami.html)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%</span>
0008 
0009 
0010 <a name="_sub0" href="#_subfunctions" class="code">function [sc_cost, Et, cvec, angle] = tps_iter_match_1(m1, m2, X, Y, orients, nbins_theta, nbins_r, r_inner, r_outer, n_iter, r, beta_init, i1, i2, anchors)   </a>
0011 
0012 <span class="comment">% script for doing shape-context based matching with alternating steps</span>
0013 <span class="comment">% of estimating correspondences and estimating the regularized TPS</span>
0014 <span class="comment">% transformation</span>
0015 <span class="comment">%anchors=[];</span>
0016 gcx=[i1];
0017 gcy=[i2];
0018 l_a=0;
0019 angle=0;
0020 angle_b=0;
0021 aff_cost=0;
0022 MAX_ANGLE=30;
0023 
0024 <span class="keyword">if</span> numel(anchors) &gt; 0
0025   gcx=[anchors(:,1)' i1];
0026   gcy=[anchors(:,2)' i2];
0027   l_a=length(anchors(:,1)');
0028   mm1=m1(anchors(:,1)',:);
0029   mm2=m2(anchors(:,2)',:);
0030   x=X(anchors(:,1)',:);
0031   y=Y(anchors(:,2)',:);
0032 <span class="keyword">else</span>
0033   mm1=[];
0034   mm2=[];
0035   x=[];
0036   y=[];
0037 <span class="keyword">end</span>
0038 
0039 m1=m1(gcx,:);
0040 m2=m2(gcy,:);
0041 
0042 ndum1=0; 
0043 ndum2=0; 
0044 eps_dum=1;
0045 nsamp1=numel(gcx);
0046 nsamp2=numel(gcy);
0047 X=X(gcx,:);
0048 Y=Y(gcy,:);
0049 
0050 mean_dist_global=[]; 
0051 display_flag = 0;
0052 Et=0;
0053 <span class="keyword">global</span> OLD_METHOD;
0054 OLD_METHOD=0;
0055 
0056 <span class="keyword">if</span> nsamp2&gt;nsamp1                                                                        
0057    <span class="comment">% (as is the case in the outlier test)</span>
0058    ndum1=ndum1+(nsamp2-nsamp1);                                              
0059 <span class="keyword">end</span>                                                                                     
0060 eps_dum=1; 
0061 
0062 <span class="comment">%JI: store minimum error in iterations to avoid</span>
0063 <span class="comment">% large jumps away from global minima to local minima</span>
0064 min_error = -1;
0065 
0066 
0067 <span class="comment">% initialize transformed version of model pointset</span>
0068 Xk=X;
0069 
0070 <span class="comment">% initialize counter</span>
0071 k=1;
0072 s=1;
0073 <span class="comment">% out_vec_{1,2} are indicator vectors for keeping track of estimated</span>
0074 <span class="comment">% outliers on each iteration</span>
0075 out_vec_1=zeros(1,nsamp1); 
0076 out_vec_2=zeros(1,nsamp2);
0077 cvec=[];
0078 
0079 <span class="keyword">while</span> s 
0080    <span class="comment">%disp(['iter=' int2str(k)])</span>
0081 
0082    <span class="comment">% compute shape contexts for (transformed) model</span>
0083 
0084 <span class="comment">%   [BH1,mean_dist_1]=sc_compute(Xk', m1(:,4)' ,mean_dist_global,nbins_theta,nbins_r,r_inner,r_outer,out_vec_1);</span>
0085    [BH1,mean_dist_1]=<a href="sc_compute.html" class="code" title="function [BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);">sc_compute</a>(Xk', zeros(1,nsamp1) ,mean_dist_global,nbins_theta,nbins_r,r_inner,r_outer,out_vec_1);
0086 
0087    <span class="comment">% compute shape contexts for target, using the scale estimate from</span>
0088    <span class="comment">% the warped model</span>
0089    <span class="comment">% Note: this is necessary only because out_vec_2 can change on each</span>
0090    <span class="comment">% iteration, which affects the shape contexts.  Otherwise, Y does</span>
0091    <span class="comment">% not change.</span>
0092 
0093 <span class="comment">%   [BH2,mean_dist_2]=sc_compute(Y',m2(:,4)',mean_dist_1,nbins_theta,nbins_r,r_inner,r_outer,out_vec_2);</span>
0094    [BH2,mean_dist_2]=<a href="sc_compute.html" class="code" title="function [BH,mean_dist]=sc_compute(Bsamp,Tsamp,mean_dist,nbins_theta,nbins_r,r_inner,r_outer,out_vec);">sc_compute</a>(Y',zeros(1,nsamp2),mean_dist_1,nbins_theta,nbins_r,r_inner,r_outer,out_vec_2);
0095 
0096    <span class="comment">% compute regularization parameter</span>
0097    beta_k=(mean_dist_1^2)*beta_init*r^(k-1);
0098 
0099    <span class="comment">% compute pairwise cost between all shape contexts</span>
0100    costmat=<a href="hist_cost_2.html" class="code" title="function [HC]=hist_cost_2(BH1,BH2, r_inner, r_outer, nbins_theta, nbins_r);">hist_cost_2</a>(BH1,BH2,r_inner, r_outer, nbins_theta, nbins_r);
0101 
0102    <span class="comment">% ensure that no negative entries in the cost matrix</span>
0103    temp = costmat &lt; eps;
0104    costmat(temp) = eps;
0105 
0106    <span class="comment">% pad the cost matrix with costs for dummies</span>
0107    nptsd=nsamp1+ndum1;
0108    costmat2=eps_dum*ones(nptsd,nptsd);
0109 
0110    <span class="comment">%JI: cost matrix with dummy nodes appended</span>
0111    costmat2(1:nsamp1,1:nsamp2)=costmat;
0112    <span class="comment">%disp('running hungarian alg.')</span>
0113 
0114    costmat2=costmat2(l_a + 1 : nsamp2, l_a+1:nsamp2);
0115 
0116    dist_m=<a href="dist2.html" class="code" title="function n2 = dist2(x, c)">dist2</a>(X(l_a + 1:nsamp1, :),Y(l_a + 1:nsamp2, :));
0117    <span class="keyword">for</span> i=1:nsamp1-l_a
0118        <span class="keyword">for</span> j=1:nsamp2-l_a 
0119            intersect_flag=0;   
0120            <span class="keyword">for</span> li=1:l_a
0121                x1=X(li,1);
0122                x2=Y(li,1);
0123                x3=X(i,1);
0124                x4=Y(j,1);
0125                y1=X(li,2);
0126                y2=Y(li,2);
0127                y3=X(i,2);
0128                y4=Y(j,2);
0129    
0130                <span class="keyword">if</span> det([1,1,1;x1,x2,x3;y1,y2,y3])*det([1,1,1;x1,x2,x4;y1,y2,y4]) &lt;= 0 &amp;&amp;  det([1,1,1;x1,x3,x4;y1,y3,y4])*det([1,1,1;x2,x3,x4;y2,y3,y4]) &lt;= 0
0131                   intersect_flag=1;   
0132                <span class="keyword">end</span>
0133            <span class="keyword">end</span>
0134            <span class="keyword">if</span> intersect_flag &amp;&amp; OLD_METHOD==1
0135               costmat2(i,j)=costmat2(i,j)+1000;
0136               <span class="keyword">continue</span>
0137            <span class="keyword">end</span>
0138 
0139            mox=m1(i,4);
0140            moy=m2(j,4);
0141            z=min(abs(mox-moy), abs(2*pi - abs(mox-moy)));
0142 <span class="comment">%       costmat2(i,j)</span>
0143 <span class="comment">%       dist_m(i,j)</span>
0144 
0145        <span class="keyword">if</span> OLD_METHOD==0
0146           costmat2(i,j)=(costmat2(i,j)+1/exp(-5*dist_m(i,j))+1/exp(-z))/5;<span class="comment">%-max(orients(i,j),0.2);</span>
0147        <span class="keyword">else</span>
0148           costmat2(i,j)=0.1*costmat2(i,j)+dist_m(i,j); <span class="comment">%-max(orients(i,j),0.2);</span>
0149        <span class="keyword">end</span>
0150 
0151            <span class="keyword">if</span> z &lt; pi/8 &amp;&amp; dist_m(i,j) &lt; 0.06
0152               costmat2(i,j)=costmat2(i,j)/2;
0153 <span class="comment">%                 else</span>
0154 <span class="comment">%                    costmat2(i,j)=costmat2(i,j) + 5*abs(costmat2(i,j));</span>
0155            <span class="keyword">end</span>
0156 
0157            <span class="keyword">if</span> m1(i,4) == m2(j,4) 
0158     <span class="comment">%             costmat2(i,j)=costmat2(i,j)*0.95;</span>
0159            <span class="keyword">end</span>
0160         <span class="keyword">end</span>
0161    <span class="keyword">end</span>
0162 
0163 
0164    <span class="keyword">if</span> numel(costmat2) &gt; 1
0165      cvec=<a href="hungarian.html" class="code" title="function [C,T]=hungarian(A)">hungarian</a>(costmat2);
0166      cvec=cvec+l_a;
0167 
0168      <span class="keyword">for</span> tt=1:numel(cvec)
0169      <span class="keyword">if</span> costmat2(cvec(tt)-l_a,tt) &gt; 1.4
0170         costmat2(cvec(tt)-l_a,tt)
0171         cvec(tt)=nsamp2;
0172      <span class="keyword">end</span>
0173      <span class="keyword">end</span>
0174    <span class="keyword">else</span>
0175      orient_res = -1;
0176      mse2 = 1;
0177      sc_cost = 1;
0178      E = 0;
0179      theta_offset_by_warping = 50;
0180      <span class="keyword">return</span>
0181    <span class="keyword">end</span>
0182 
0183    cvec=[1:l_a cvec]
0184 
0185    <span class="comment">% update outlier indicator vectors</span>
0186    [a,cvec2]=sort(cvec);
0187   <span class="comment">% out_vec_1=cvec2(1:nsamp1)&gt;nsamp2;</span>
0188   <span class="comment">% out_vec_2=cvec(1:nsamp2)&gt;nsamp1;             %JI: cvec points to X match</span>
0189      
0190    <span class="comment">% format versions of Xk and Y that can be plotted with outliers'</span>
0191    <span class="comment">% correspondences missing</span>
0192 
0193    X2=NaN*ones(nptsd,2);
0194    m1a = NaN*ones(nsamp2,6);
0195    X2(1:nsamp1,:)=Xk;
0196    m1a(1:nsamp1, :) = m1;
0197    X2=X2(cvec,:);
0198   
0199    m1a = m1a(cvec, :);
0200    X2b=NaN*ones(nptsd,2);
0201    X2b(1:nsamp1,:)=X;  
0202    X2b=X2b(cvec,:);
0203    m2a = m2;
0204 
0205    Y2=NaN*ones(nptsd,2); 
0206    Y2(1:nsamp2,:)=Y;
0207 
0208    <span class="comment">% extract coordinates of non-dummy correspondences and use them</span>
0209    <span class="comment">% to estimate transformation</span>
0210    ind_good=intersect(find(~isnan(X2b(:,1))), find(~isnan(Y2(:,1))));
0211 <span class="comment">%   ind_good=intersect(find(~isnan(X2b(:,1))), find(~isnan(Y2(:,1))))</span>
0212 
0213 
0214    dd=<a href="dist2.html" class="code" title="function n2 = dist2(x, c)">dist2</a>(X2b(ind_good,:),Y2(ind_good,:)); 
0215    i_vgood=1:l_a ;<span class="comment">%[];</span>
0216    <span class="keyword">for</span> i=l_a+1:min(numel(ind_good), nsamp1)
0217        <span class="keyword">if</span> dd(i,i) &lt; 0.1
0218           i_vgood = [i_vgood i];
0219        <span class="keyword">end</span>
0220    <span class="keyword">end</span>
0221    ind_good = ind_good(i_vgood);   
0222 
0223    n_good=length(ind_good);
0224 
0225    X3b=X2b(ind_good,:);
0226    Y3=Y2(ind_good,:);
0227 
0228    m1a = m1a(ind_good,:);
0229    m2a = m2a(ind_good,:);
0230 
0231    n_good=length(ind_good);
0232 
0233 
0234    <span class="keyword">if</span> display_flag == 0
0235       subplot(2,2,2);
0236       plot(X2(:,1),X2(:,2),<span class="string">'b+'</span>,Y2(:,1),Y2(:,2),<span class="string">'ro'</span>)
0237       hold on
0238       h=plot([X2(:,1) Y2(:,1)]',[X2(:,2) Y2(:,2)]',<span class="string">'k-'</span>);
0239       hold off
0240       title([int2str(n_good) <span class="string">' correspondences (warped X)'</span>])
0241       drawnow    
0242       <span class="comment">% show the correspondences between the untransformed images</span>
0243       subplot(2,2,3);
0244       plot(X(:,1),X(:,2),<span class="string">'b+'</span>,Y(:,1),Y(:,2),<span class="string">'ro'</span>)
0245       ind=cvec(ind_good);
0246       hold on
0247       plot([X2b(:,1) Y2(:,1)]',[X2b(:,2) Y2(:,2)]',<span class="string">'k-'</span>)
0248       hold off
0249       title([int2str(n_good) <span class="string">' correspondences (unwarped X)'</span>])
0250       drawnow    
0251    <span class="keyword">end</span>
0252 
0253    <span class="comment">% estimate regularized TPS transformation</span>
0254    <span class="keyword">if</span> numel(X3b) &gt; 1
0255       [cx,cy,E]=<a href="bookstein.html" class="code" title="function [cx,cy,E,L]=bookstein(X,Y,beta_k);">bookstein</a>(X3b,Y3,beta_k);  
0256       <span class="keyword">if</span> isnan(cx(1))
0257          mse2 = 1;
0258          sc_cost = 1;
0259          <span class="keyword">break</span>
0260       <span class="keyword">end</span>
0261    <span class="keyword">else</span>
0262      mse2 = 1;
0263      sc_cost = 1;
0264      E = 50;
0265      <span class="keyword">return</span>
0266    <span class="keyword">end</span>
0267    Et=Et+E;
0268 
0269    <span class="comment">% calculate affine cost</span>
0270    A=[cx(n_good+2:n_good+3,:) cy(n_good+2:n_good+3,:)]
0271    [cx(n_good+2:n_good+3,:)]
0272    A(2,1)
0273    A(1,1)
0274 
0275    [U,S,V]=svd(A);
0276    
0277    angle_b=angle_b + ((atan2( V(1,2) ,  V(1,1))*180/pi) - (atan2( U(1,2) ,  U(1,1))*180/pi));
0278    (atan2( V(1,2) ,  V(1,1))*180/pi) 
0279    (atan2( U(1,2) ,  U(1,1))*180/pi)
0280 
0281    <span class="comment">% JA: Compute the eigenvalues of A in an array, ordered descending.</span>
0282    s=svd(A)                      
0283    aff_cost=aff_cost + log(s(1)/s(2))
0284    <span class="comment">%angle=abs(atan2( A(1,2) ,  A(2,2))*180/pi)</span>
0285    angle=angle + (atan2( A(2,1) ,  A(1,1))*180/pi);
0286 
0287    orient_m = 0; 
0288    sc_cost = [];
0289    index = 0;
0290    m_index = 0;
0291    bad_count = 0;
0292 
0293    <span class="comment">% warp each coordinate</span>
0294    fx_aff=cx(n_good+1:n_good+3)'*[ones(1,nsamp1); X'];
0295    d2=max(<a href="dist2.html" class="code" title="function n2 = dist2(x, c)">dist2</a>(X3b,X),0);
0296    U=d2.*log(d2+eps);
0297    fx_wrp=cx(1:n_good)'*U;
0298    fx=fx_aff+fx_wrp;
0299    fy_aff=cy(n_good+1:n_good+3)'*[ones(1,nsamp1); X'];
0300    fy_wrp=cy(1:n_good)'*U;
0301    fy=fy_aff+fy_wrp;
0302 
0303    Z=[fx; fy]';
0304 
0305    Zk=NaN*ones(nptsd,2);
0306    Zk(1:nsamp1,:)=Z;
0307    Zk=Zk(cvec,:);
0308    Zk = Zk(ind_good, :);
0309 
0310    <span class="comment">% compute theta_offset_by_warping from Xk and Z, and update</span>
0311    <span class="comment">% theta_offset_total</span>
0312    Diff = Xk - Z;
0313    diff_x = sum(Diff(:,1));
0314    diff_y = sum(Diff(:,2));
0315 
0316    <span class="comment">% compute the mean squared error between synthetic warped image</span>
0317    <span class="comment">% and estimated warped image (using ground-truth correspondences</span>
0318    <span class="comment">% on TPS transformed image)</span>
0319 
0320  <span class="comment">%  mse2=sqrt(mean((Y3(:,1)-Z(:,1)).^2+(Y3(:,2)-Z(:,2)).^2) );</span>
0321 
0322   <span class="comment">% mse2=sqrt(mean((Y3(:,1)-Zk(:,1)).^2+(Y3(:,2)-Zk(:,2)).^2) );</span>
0323 mse2=0;
0324 <span class="comment">%   disp(['error = ' num2str(mse2)])</span>
0325 
0326    <span class="keyword">if</span> 0<span class="comment">%display_flag == 0</span>
0327       plot(Z(:,1),Z(:,2),<span class="string">'b+'</span>,Y(:,1),Y(:,2),<span class="string">'ro'</span>);
0328       title([<span class="string">'recovered TPS transformation (k='</span> int2str(k) <span class="string">', \lambda_o='</span> num2str(beta_init*r^(k-1)) <span class="string">', I_f='</span> num2str(E) <span class="string">', error='</span> num2str(mse2) <span class="string">')'</span>]) 
0329       <span class="comment">% show warped coordinate grid</span>
0330       hold on
0331       plot(fx,fy,<span class="string">'k.'</span>,<span class="string">'markersize'</span>,1)
0332       hold off
0333       drawnow
0334    <span class="keyword">end</span>
0335    
0336    <span class="comment">% update Xk for the next iteration</span>
0337    Xk=Z;
0338    
0339    <span class="comment">% stop early if shape context score is sufficiently low</span>
0340    <span class="keyword">if</span> k==n_iter || Et &gt; 1000
0341       s=0;
0342    <span class="keyword">else</span>
0343       k=k+1;
0344    <span class="keyword">end</span>
0345 <span class="keyword">end</span>
0346 
0347 
0348 <span class="comment">%Y(cvec(l_a+1:nsamp1),:)</span>
0349 <span class="comment">%Xk(cvec(l_a+1:nsamp1),:)</span>
0350 <span class="comment">%X(cvec(l_a+1:nsamp1),:)</span>
0351 
0352 cvec=cvec(l_a+1:nsamp2);
0353 
0354 angle
0355 angle_b=min(abs(angle_b), 360-abs(angle_b))
0356 
0357 <span class="comment">%pause</span>
0358 map=[];
0359 index=1;
0360 angle=angle_b;
0361 aff_cost
0362 
0363 
0364 <span class="comment">%aff_cost=0.3 works well</span>
0365 <span class="comment">% [ig,ib]=calc_EER(1./(RES_G-0.3*SC_G+0.3),  1./(RES_B-0.3*SC_B+0.3)); hold on ; plot(ig,'b'); plot(ib,'r');hold off;   axis([0 75 0.5 1]);</span>
0366 
0367 <span class="keyword">if</span> abs(angle) &lt; MAX_ANGLE &amp;&amp; E &lt; 15 &amp;&amp; aff_cost &lt; 0.3
0368 
0369 <span class="comment">%if angle &lt; 30 &amp;&amp; E &lt; 15 %|| isnan(E)</span>
0370 <span class="comment">%if angle &lt; 15 &amp;&amp; Et &lt; 13 %|| isnan(E)</span>
0371    <span class="keyword">for</span> i=1:nsamp2-l_a
0372        <span class="keyword">if</span> cvec(i) &lt;= nsamp1 
0373            intersect_flag=0;   
0374 
0375            d1=sqrt( (X(cvec(i),1)-Y(i,1))^2 + (X(cvec(i),2)-Y(i,2))^2);
0376            d1=sqrt( (Xk(cvec(i),1)-Y(i,1))^2 + (X(cvec(i),2)-Y(i,2))^2);
0377        dist_m=<a href="dist2.html" class="code" title="function n2 = dist2(x, c)">dist2</a>(X(l_a + 1:nsamp1, :),Y(l_a + 1:nsamp2, :));
0378         
0379 <span class="comment">%           if OLD_METHOD==1</span>
0380                <span class="keyword">for</span> li=1:l_a
0381                   x1=X(li,1);
0382                   x2=Y(li,1);
0383                   x3=X(cvec(i),1);
0384                   x4=Y(i,1);
0385                   y1=X(li,2);
0386                   y2=Y(li,2);
0387                   y3=X(cvec(i),2);
0388                   y4=Y(i,2);
0389    
0390                   <span class="keyword">if</span> det([1,1,1;x1,x2,x3;y1,y2,y3])*det([1,1,1;x1,x2,x4;y1,y2,y4]) &lt;= 0 &amp;&amp;  det([1,1,1;x1,x3,x4;y1,y3,y4])*det([1,1,1;x2,x3,x4;y2,y3,y4]) &lt;= 0
0391                      intersect_flag=1   
0392                   <span class="keyword">end</span>
0393                <span class="keyword">end</span>
0394 <span class="comment">%           end</span>
0395 
0396        <span class="keyword">if</span> intersect_flag==1 &amp;&amp; costmat(cvec(i), i) &gt; 1
0397         ll=costmat(cvec(i), i) 
0398         <span class="keyword">continue</span>
0399        <span class="keyword">end</span>
0400 
0401            <span class="keyword">if</span> (costmat(cvec(i), i) &lt; 1.31 &amp;&amp; OLD_METHOD==0) ||  (d1 &lt; 0.013 &amp;&amp; intersect_flag==0 &amp;&amp; OLD_METHOD==1) <span class="comment">% &amp;&amp; costmat(cvec(i), i) &lt; 20</span>
0402                map(index,:)=[cvec(i)-l_a,i];
0403                index=index+1;
0404            <span class="keyword">else</span>
0405            ll=costmat(cvec(i), i) 
0406            <span class="keyword">end</span>
0407        <span class="keyword">end</span>
0408    <span class="keyword">end</span>
0409 <span class="keyword">end</span>
0410 
0411 cvec=map;
0412 
0413 aff_cost</pre></div>
<hr><address>Generated on Wed 16-Apr-2014 19:12:41 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>